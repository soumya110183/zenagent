import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import html2canvas from 'html2canvas';
import { type Project, type AnalysisData } from '@shared/schema';
import zensarLogo from "@assets/zenlogo_1754679408998.png";

// Extend jsPDF type for autotable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface PDFExportOptions {
  project: Project;
  analysisData: AnalysisData;
  includeAllDiagrams?: boolean;
  sonarAnalysis?: any;
  swaggerData?: any;
  comprehensiveData?: any;
  structureData?: any;
}

export class PDFExportService {
  private doc: jsPDF;
  private pageHeight: number;
  private pageWidth: number;
  private currentY: number;
  private margin: number;
  private lineHeight: number;

  constructor() {
    this.doc = new jsPDF('p', 'mm', 'a4');
    this.pageHeight = this.doc.internal.pageSize.height;
    this.pageWidth = this.doc.internal.pageSize.width;
    this.margin = 20;
    this.currentY = this.margin;
    this.lineHeight = 7;
  }

  async exportProjectAnalysis(options: PDFExportOptions): Promise<void> {
    const { project, analysisData, sonarAnalysis, swaggerData, comprehensiveData, structureData } = options;
    const aiInsights = analysisData.aiAnalysis;
    const projectDetails = aiInsights?.projectDetails;

    // Cover Page with Zensar branding
    this.createCoverPage(project);
    
    // Document Revision History
    this.addNewPage();
    this.createRevisionHistory();
    
    // Table of Contents
    this.addNewPage();
    this.createTableOfContents();
    
    // Project Overview
    this.addNewPage();
    this.addSection('1. Project Overview', () => {
      this.addProjectOverview(project, analysisData);
    });

    // Project Details
    if (projectDetails) {
      this.addSection('2. Project Analysis Details', () => {
        this.addProjectDetails(projectDetails);
      });
    }

    // Architecture Analysis
    this.addSection('3. Architecture Analysis', () => {
      this.addArchitectureAnalysis(analysisData);
    });

    // Code Structure
    this.addSection('4. Code Structure', () => {
      this.addCodeStructure(analysisData);
    });

    // Project Structure
    if (structureData) {
      this.addSection('5. Project Structure', () => {
        this.addProjectStructure(structureData);
      });
    }

    // AI Insights
    if (aiInsights) {
      this.addSection('6. AI-Powered Insights', () => {
        this.addAIInsights(aiInsights);
      });
    }

    // Diagrams Section
    this.addSection('7. Architecture Diagrams', () => {
      this.addText('The following diagrams provide visual representations of the project architecture:');
      this.addSpace(10);
    });

    // Export diagrams
    await this.exportDiagrams(['flow', 'component', 'class', 'sequence', 'er']);

    // Add headers and footers to all pages
    this.finalizeDocument();

    // Save the PDF with proper document name
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
    this.doc.save(`${project.name}-Project-Analysis-Document-${timestamp}.pdf`);
  }

  private addHeaderFooter(): void {
    // Note: Headers and footers will be added after all pages are created
    // This is called at the end of the export process
  }

  private createCoverPage(project: Project): void {
    this.currentY = 40;
    
    // Add Zensar Logo (top right) if available
    try {
      if (zensarLogo) {
        this.doc.addImage(zensarLogo, 'PNG', this.pageWidth - 60, 20, 40, 15);
      }
    } catch (error) {
      console.log('Logo not available, continuing without it');
    }
    
    // Title
    this.doc.setFontSize(32);
    this.doc.setTextColor(0, 51, 102); // Zensar blue
    this.doc.text('Project Analysis Document', this.pageWidth / 2, this.currentY, { align: 'center' });
    
    this.currentY += 25;
    this.doc.setFontSize(22);
    this.doc.setTextColor(50, 50, 50);
    this.doc.text(project.name, this.pageWidth / 2, this.currentY, { align: 'center' });
    
    this.currentY += 15;
    this.doc.setFontSize(14);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text('Comprehensive Architecture Analysis & Documentation', this.pageWidth / 2, this.currentY, { align: 'center' });
    
    this.currentY += 40;
    
    // Project info box with Zensar styling
    this.doc.setFillColor(240, 248, 255); // Light blue background
    this.doc.setDrawColor(0, 51, 102); // Zensar blue border
    this.doc.rect(this.margin, this.currentY, this.pageWidth - 2 * this.margin, 80, 'FD');
    
    this.currentY += 15;
    this.doc.setFontSize(12);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text('Generated by:', this.margin + 10, this.currentY);
    this.doc.setTextColor(0, 51, 102);
    this.doc.text('Zengent AI - Enterprise Application Intelligence Platform', this.margin + 50, this.currentY);
    
    this.currentY += 12;
    this.doc.setTextColor(0, 0, 0);
    this.doc.text('Date:', this.margin + 10, this.currentY);
    this.doc.text(new Date().toLocaleDateString('en-GB'), this.margin + 50, this.currentY);
    
    this.currentY += 12;
    this.doc.text('Analysis Type:', this.margin + 10, this.currentY);
    this.doc.text('Enterprise Application Intelligence Analysis', this.margin + 50, this.currentY);
    
    this.currentY += 12;
    this.doc.text('Document Type:', this.margin + 10, this.currentY);
    this.doc.text('Project Analysis Document', this.margin + 50, this.currentY);
    
    this.currentY += 12;
    this.doc.text('Version:', this.margin + 10, this.currentY);
    this.doc.text('1.0', this.margin + 50, this.currentY);
    
    // Copyright footer on cover page
    this.doc.setFontSize(10);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text('Copyright Â© Zensar Technologies Ltd.', this.pageWidth / 2, this.pageHeight - 30, { align: 'center' });
    this.doc.text('Prepared by Diamond Zensar Team', this.pageWidth / 2, this.pageHeight - 20, { align: 'center' });
  }

  private createRevisionHistory(): void {
    this.addTitle('Document Revision History');
    this.addSpace(10);

    // Create revision table
    const revisionData = [
      ['Role', 'Version', 'Date', 'Remarks'],
      ['System Analyst', '1.0', '08/05/2025', 'Initial project analysis document creation'],
      ['', '', '', ''],
      ['', '', '', ''],
      ['', '', '', '']
    ];

    this.doc.autoTable({
      head: [revisionData[0]],
      body: revisionData.slice(1),
      startY: this.currentY,
      margin: { left: this.margin, right: this.margin },
      theme: 'grid',
      styles: {
        fontSize: 10,
        cellPadding: 5,
        lineColor: [0, 51, 102],
        lineWidth: 0.5
      },
      headStyles: {
        fillColor: [0, 51, 102],
        textColor: [255, 255, 255],
        fontStyle: 'bold'
      },
      columnStyles: {
        0: { cellWidth: 40 },
        1: { cellWidth: 25 },
        2: { cellWidth: 30 },
        3: { cellWidth: 75 }
      }
    });

    this.currentY = (this.doc as any).lastAutoTable.finalY + 20;
  }

  private createTableOfContents(): void {
    this.addTitle('Table of Contents');
    this.addSpace(10);
    
    const contents = [
      '1. Project Overview ............................................................... 3',
      '2. Project Analysis Details .................................................... 4',
      '3. Architecture Analysis ....................................................... 5',
      '4. Code Structure ............................................................... 6',
      '5. Project Structure ............................................................ 7',
      '6. AI-Powered Insights ......................................................... 8',
      '7. Architecture Diagrams ....................................................... 9'
    ];
    
    contents.forEach(item => {
      this.addText(item);
      this.addSpace(5);
    });
  }

  private addProjectOverview(project: Project, analysisData: AnalysisData): void {
    this.addSubtitle('Project Summary');
    this.addText(`Project Name: ${project.name}`);
    this.addText(`Analysis Date: ${new Date().toLocaleDateString()}`);
    this.addText(`Files Analyzed: ${analysisData.structure.sourceFiles.length}`);
    this.addSpace(10);
    
    // Statistics
    const controllers = analysisData.classes.filter(c => c.type === 'controller');
    const services = analysisData.classes.filter(c => c.type === 'service');
    const repositories = analysisData.classes.filter(c => c.type === 'repository');
    const entities = analysisData.classes.filter(c => c.type === 'entity');
    
    this.addSubtitle('Project Statistics');
    this.addText(`â€¢ Controllers: ${controllers.length}`);
    this.addText(`â€¢ Services: ${services.length}`);
    this.addText(`â€¢ Repositories: ${repositories.length}`);
    this.addText(`â€¢ Entities: ${entities.length}`);
    this.addText(`â€¢ Total Classes: ${analysisData.classes.length}`);
    this.addText(`â€¢ Relationships: ${analysisData.relationships.length}`);
  }

  private addProjectDetails(projectDetails: any): void {
    this.addSubtitle('Project Description');
    this.addWrappedText(projectDetails.projectDescription);
    this.addSpace(10);
    
    this.addSubtitle('Business Problem Addressed');
    this.addWrappedText(projectDetails.businessProblem);
    this.addSpace(10);
    
    this.addSubtitle('Key Objective');
    this.addWrappedText(projectDetails.keyObjective);
    this.addSpace(10);
    
    this.addSubtitle('Summary of Functionality');
    this.addWrappedText(projectDetails.functionalitySummary);
    this.addSpace(10);
    
    this.addSubtitle('Implemented Features');
    projectDetails.implementedFeatures.forEach((feature: string) => {
      this.addText(`â€¢ ${feature}`);
    });
    this.addSpace(10);
    
    this.addSubtitle('Modules and Services');
    projectDetails.modulesServices.forEach((module: string) => {
      this.addText(`â€¢ ${module}`);
    });
  }

  private addArchitectureAnalysis(analysisData: AnalysisData): void {
    this.addSubtitle('Detected Patterns');
    
    const hasControllers = analysisData.classes.some(c => c.type === 'controller');
    const hasServices = analysisData.classes.some(c => c.type === 'service');
    const hasRepositories = analysisData.classes.some(c => c.type === 'repository');
    
    if (hasControllers && hasServices && hasRepositories) {
      this.addText('âœ“ Layered Architecture Pattern Detected');
      this.addText('âœ“ Separation of Concerns Implemented');
    }
    
    const springAnnotations = analysisData.classes.filter(c => 
      c.annotations.some(a => a.includes('@Controller') || a.includes('@Service') || a.includes('@Repository'))
    );
    
    if (springAnnotations.length > 0) {
      this.addText('âœ“ Spring Framework Annotations Used');
      this.addText('âœ“ Dependency Injection Pattern');
    }
    
    this.addSpace(10);
    
    // Annotations Found
    this.addSubtitle('Annotations Found');
    const annotations = analysisData.classes
      .flatMap((c: any) => c.annotations || [])
      .filter((a: string, i: number, arr: string[]) => arr.indexOf(a) === i); // unique
    
    if (annotations.length > 0) {
      annotations.slice(0, 15).forEach(annotation => {
        this.addText(`â€¢ ${annotation}`);
      });
      if (annotations.length > 15) {
        this.addText(`  ... and ${annotations.length - 15} more`);
      }
    } else {
      this.addText('No annotations found');
    }
    
    this.addSpace(10);
    
    this.addSubtitle('Quality Metrics');
    const qualityScore = analysisData.aiAnalysis?.qualityScore || 0;
    this.addText(`Overall Quality Score: ${qualityScore}/100`);
    
    if (qualityScore >= 80) {
      this.addText('â€¢ Excellent code organization and architecture');
    } else if (qualityScore >= 60) {
      this.addText('â€¢ Good code structure with room for improvement');
    } else {
      this.addText('â€¢ Consider refactoring for better architecture');
    }
  }

  private addCodeStructure(analysisData: AnalysisData): void {
    this.addSubtitle('Package Structure');
    
    const packages = new Set<string>();
    analysisData.classes.forEach(cls => {
      packages.add(cls.package);
    });
    
    Array.from(packages).sort().forEach(pkg => {
      this.addText(`â€¢ ${pkg}`);
    });
    
    this.addSpace(10);
    
    this.addSubtitle('Class Distribution by Type');
    const classTypes = ['controller', 'service', 'repository', 'entity', 'component', 'configuration'];
    
    classTypes.forEach(type => {
      const count = analysisData.classes.filter(c => c.type === type).length;
      if (count > 0) {
        this.addText(`â€¢ ${type.charAt(0).toUpperCase() + type.slice(1)}: ${count} classes`);
      }
    });
  }

  private addProjectStructure(structureData: any): void {
    this.addSubtitle('Directory Structure');
    this.addText('Overview of the project directory organization:');
    this.addSpace(5);
    
    if (structureData.structure) {
      let itemCount = 0;
      const maxItems = 50; // Limit for PDF to avoid overflow
      
      const renderStructure = (item: any, level: number = 0): void => {
        if (itemCount >= maxItems) return;
        
        const indent = '  '.repeat(level);
        const icon = item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
        const suffix = item.type === 'directory' ? '/' : '';
        
        this.addText(`${indent}${icon} ${item.name}${suffix}`);
        itemCount++;
        
        if (item.children && item.children.length > 0 && itemCount < maxItems) {
          item.children.forEach((child: any) => {
            renderStructure(child, level + 1);
          });
        }
      };
      
      renderStructure(structureData.structure);
      
      if (itemCount >= maxItems) {
        this.addSpace(5);
        this.addText('... (structure truncated for brevity)');
      }
    }
  }

  private addAIInsights(aiInsights: any): void {
    this.addSubtitle('Project Overview');
    if (aiInsights.projectOverview) {
      this.addWrappedText(aiInsights.projectOverview);
    }
    
    this.addSpace(10);
    
    this.addSubtitle('Architecture Recommendations');
    if (aiInsights.suggestions && aiInsights.suggestions.length > 0) {
      aiInsights.suggestions.forEach((suggestion: string) => {
        this.addText(`â€¢ ${suggestion}`);
      });
    }
    
    this.addSpace(10);
    
    if (aiInsights.architectureInsights && aiInsights.architectureInsights.length > 0) {
      this.addSubtitle('Technical Insights');
      aiInsights.architectureInsights.forEach((insight: string) => {
        this.addText(`â€¢ ${insight}`);
      });
    }
  }

  private async exportDiagrams(diagramTypes: string[]): Promise<void> {
    for (const type of diagramTypes) {
      await this.captureDiagram(type);
    }
  }

  private async captureDiagram(type: string): Promise<void> {
    try {
      // Trigger diagram type change - Radix UI uses data-value attribute
      const tabTrigger = document.querySelector(`[data-value="${type}"]`) as HTMLElement;
      if (tabTrigger) {
        tabTrigger.click();
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for diagram to render
      } else {
        console.warn(`Could not find tab trigger for diagram type: ${type}`);
      }

      const diagramElement = document.querySelector('.react-flow') as HTMLElement;
      if (diagramElement) {
        const canvas = await html2canvas(diagramElement, {
          backgroundColor: '#ffffff',
          scale: 1,
          width: 800,
          height: 600
        });

        this.addNewPage();
        this.addSubtitle(`${type.charAt(0).toUpperCase() + type.slice(1)} Diagram`);
        this.addSpace(10);

        const imgData = canvas.toDataURL('image/jpeg', 0.8);
        const imgWidth = this.pageWidth - 2 * this.margin;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;

        if (this.currentY + imgHeight > this.pageHeight - this.margin) {
          this.addNewPage();
        }

        this.doc.addImage(imgData, 'JPEG', this.margin, this.currentY, imgWidth, imgHeight);
        this.currentY += imgHeight + 10;
      }
    } catch (error) {
      console.error(`Failed to capture ${type} diagram:`, error);
      this.addText(`${type} diagram could not be captured`);
    }
  }

  private addSection(title: string, content: () => void): void {
    this.addTitle(title);
    this.addSpace(10);
    content();
    this.addSpace(20);
  }

  private addTitle(text: string): void {
    this.doc.setFontSize(16);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight + 5;
  }

  private addSubtitle(text: string): void {
    this.doc.setFontSize(12);
    this.doc.setTextColor(50, 50, 50);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight;
  }

  private addText(text: string): void {
    this.doc.setFontSize(10);
    this.doc.setTextColor(0, 0, 0);
    this.doc.text(text, this.margin, this.currentY);
    this.currentY += this.lineHeight;
    
    if (this.currentY > this.pageHeight - this.margin - 20) {
      this.addNewPage();
    }
  }

  private addWrappedText(text: string): void {
    this.doc.setFontSize(10);
    this.doc.setTextColor(0, 0, 0);
    
    const maxWidth = this.pageWidth - 2 * this.margin;
    const lines = this.doc.splitTextToSize(text, maxWidth);
    
    lines.forEach((line: string) => {
      if (this.currentY > this.pageHeight - this.margin - 20) {
        this.addNewPage();
      }
      this.doc.text(line, this.margin, this.currentY);
      this.currentY += this.lineHeight;
    });
  }

  private addSpace(space: number): void {
    this.currentY += space;
    
    if (this.currentY > this.pageHeight - this.margin - 20) {
      this.addNewPage();
    }
  }

  private addNewPage(): void {
    this.doc.addPage();
    this.currentY = this.margin + 10;
  }

  private finalizeDocument(): void {
    const pageCount = this.doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      this.doc.setPage(i);
      
      // Header
      this.doc.setFontSize(10);
      this.doc.setTextColor(100, 100, 100);
      this.doc.text('Zengent - Multi-Language Architecture Analyzer', this.margin, 15);
      
      // Header line
      this.doc.setDrawColor(200, 200, 200);
      this.doc.line(this.margin, 18, this.pageWidth - this.margin, 18);
      
      // Footer
      this.doc.text(`Page ${i}`, this.pageWidth - this.margin - 15, this.pageHeight - 10);
      this.doc.text(new Date().toLocaleDateString(), this.margin, this.pageHeight - 10);
      
      // Footer line
      this.doc.line(this.margin, this.pageHeight - 15, this.pageWidth - this.margin, this.pageHeight - 15);
    }
  }
}

export const pdfExportService = new PDFExportService();